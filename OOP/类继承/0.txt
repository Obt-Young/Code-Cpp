1    -    子类不能直接访问基类的私有成员，必须通过基类的方法进行访问。例如构造函数不能直接赋值，而需要调用基类的构造函数来实现给成员变量的赋值。
2    -    创建派生类对象时，程序首先调用基类构造函数，然后在调用派生类构造函数
	  基类构造函数负责：初始化基类的成员变量
	  派生类的构造函数负责：初始化新增的数据成员，如果不通过“初始化器列表语法”来指定基类构造函数，那么就使用默认基类构造函数

(!!!)3   -   重点：如果不想用默认的基类构造函数，那么“必须”使用初始化器列表语法，语法规则如下：
			子类::子类(int arg1,int arg2):基类(arg1,arg2)
			{

			}
		      案例：
			RatedPlayer::RatedPlayer(const string &firstname_, const string &lastname_, bool hasTable_, unsigned int rating_)
				:TableTennisPlayer(firstname_,lastname_,hasTable_)
			{
				rating = rating_;
			}

4    -    基类和派生类之间的关系：1）派生类可使用基类的非private方法
				  2）基类指针可以指向派生类，但是！！！不能使用派生类的方法(那有个P用)
				  3）派生类指针不能指向基类
			注：关于指向这一块，好像和JAVA正好相反。

		可以这样记忆：每个指针都有自己的成员变量和成员函数列表，一旦定义了是什么类型的指针，那么可访问的列表就确定了。那么基类指针指向
                              派生类时，基类只能看到属于自己的成员变量和函数列表，因为派生类时继承自基类的，所以理所当然包含这些成员。
                              那么，如果让派生类指针指向基类，那么派生类指针是包含自己独特的成员变量和成员函数的，但是基类是没有的，所以用来
                              作用于基类实例肯定不行。
		




5    -    函数的多态：对于同一个方法(方法名和参数列表)，不同的类调用，效果是不同的   （多个类）   （在java里，这有叫做覆盖，即“同名同参调用就近原则”）
	  函数的重载：对于同名方法(方法名相同，参数列表不同)，效果是不同的	       （单个类）

6    -    有两种方法可以实现多态：
		1）在派生类中重新定义基类的方法（同名同参）
		2）使用虚方法（！！！）



7    -    虚函数，跟着实例走
          不是虚函数，跟着引用/指针走

8    -    如果某个函数可能是多态的，那么在基类中将其定义为virtual的，这样就能够通过类指针来分别调用基类和派生类的当前多态函数
    			注：这个应该就是java中的super

9    -    如果某个函数时virtual的，那么其派生类的同名方法也会被自动设置为virtual(即使没有指明virtual，它也是virtual的，c++应该会完成这种转换)，但是一般还是会手动指定virtual

10   -    virtual关键字只在类定义的函数声明中使用即可，在函数实现时不需要指定

11   -    再说一遍：派生类不能直接访问基类的成员变量(因为那是private的)，所以有两种方法可以访问：
		1）通过调用基类的方法，但是这个方法包含访问成员变量的语句（语法很简单粗暴，直接   基类名::方法  ），此时不需要实例化一个基类，因为派生类在调用构造函数的时候
                   已经创建一个了。详情，见三号工程中派生类的 ViewAcct 和 Withdraw 方法。
		2）调用基类的友元函数，前提是基类定义了友元函数

12   -    基类指针不仅能操作子类的实例，还能操作孙类的实例，有传递性

13   -    虚函数的一些要点：
		1）每个对象都将增大，增大量为存储地址的空间
		2）对于每个类，编译器都创建一个虚函数地址表 （数组）
		3）对于每个函数调用，都需要执行一项额外操作，即到表中查找地址

14   -    使用虚函数需要注意：
		1）使用virtual关键字把基类的函数声明为虚函数后，此方法在所有派生类(子类，孙类)中都是虚的，因为是继承，所以方法自然而然原封不动地继承下去，顾也是虚的
		2）见 #7
		3）如果基类中是虚方法，现在在子类中需要对其进行多态重写，那么重写的方法也“必须”是虚的（貌似编译器会自动转，不过保险起见还是注明了好）
		4）构造函数不能是虚函数
		5）析构函数应当是虚函数，除非这个类就不想作基类，但是为了可扩展性，还是推荐所有析构函数都是虚函数
		6）友元函数不能是虚函数

(!!!)15   -    一些不常用的经验：
		1）如果重新定义继承的方法，那么一定要和基类方法一模一样（函数名，参数列表，返回值，虽然返回值可以不一样，但是建议都定义成一样的），如果返回值是基类引用或指针，
		   那么返回一个派生类引用或指针也是可以的，这叫做“返回类型协变”。（可以理解为，基类指针是可以指向派生类实例的，这点在前面的虚函数使用中已经说明了，见#4）
		2）如果基类某个函数有重载现象，那么在派生类中需要把所有重载函数都重新再写一遍（这尼玛，累死人了）。
			
	(重要！！！！)	比如，基类A，派生类B，基类A中有方法func(void) , func (int),func (int , int)
			      那么B必须把这三个func都ctrl+c , ctrl+v 一遍，
		如果B只ctrl+c，ctrl+v func(void),或者自己还改了点东西，那么其他两个func都将无法使用，即B只有一个func，就是func(void)

16   -    protected关键字：和JAVA一样。
			某个类，如果有procted修饰的成员，那么这些成员只能被自己和自己的子类（包括孙类）使用


（！！）17   -   设计理念：
			1）类A和类B，B继承A
			2）类A和类B，找出A和B的共同点，用共同点创建一个C，A和B都继承C

18   -   需要细读：13.6  13.4 13.7


（！！）19   -   默认构造函数有两种情况：1）没有参数  Brass::Brass(){
					      }
				 2）每个参数都有默认值 Brass::Brass(int a=0,char b='c',const string &name="wahaha"){
						       }

（！！）20   -   复制构造函数：复制构造函数接收其所属类的对象作为参数。
			Brass::Brass(const Brass & ptr)
			{

			}

21   -  构造函数不能被继承（这个很容易理解，但是需要说明一下，以免脑热） 





