有如下案例：


class B{

public:
	void f(double);

};

class D:class B{
	void f(int);

}



D d;
d.f(12.3);


这个时候会有问题，这种情况因为在D中搜到了f，所以会使用D的f，但是类型不匹配，虽然最终会通过强制类型转换强制使用，但是编译时会告警，而且会有精度损失

这种场景下，无论如何都是无法通过D的实例来访问B的f的，即便是按照“虚函数跟着实力走，非虚函数跟着指针走”的方法

