#1   ---   c++和QML结合使用：
		1）思路：a.把c++类注册到QML中，成为一个QML类，再通过QML来创建和使用
			 b.把c++类实例化一个实例，然后把这个实例传给QML，QML直接使用对这个实例操作
		    小结：不论如何，都是把c++代码做成封装，给QML调用，这个和QML语言的实现思路是一致的，都是通过c++写底层，然后中间封装一层，再提供QML接口，
                          起始也就“相当于自己扩展开发QML语言了”

		2）准备：a.在c++类必须继承Qobject类
			 b.在c++类的开头必须使用Q_OBJECT宏

=========================================================================================================================================================

#2   ---   手段：1）通过信号和槽  互相关联
			 QML中有信号和槽，c++中也有信号和槽。而且QML和c++的信号和槽是互通的，那么就可以用这个机制来做关联。
			 在QML中注册信号和槽，来对应c++中的槽和信号。
				QML	 c++
				信号-----槽
				槽-------信号

		 2）通过Q_INVOKABLE宏  使用c++类方法
			凡是被此宏修饰的public成员方法都可以在QML中使用，使用方法就是  类名.方法

		 3）通过Q_ENUMS宏  使用c++类的枚举成员变量
			凡是被此宏处理过的枚举类型，都可以在QML中使用，方法为  类名.枚举的值  (这里不是 类名.枚举类型名.枚举的值)(那如果修饰了多个枚举类型怎么办？)

		 4）

=========================================================================================================================================================

如果想要模块化编程，那么就要单独定义一些模块，在QT里，这些可被其他qml引用的模块就叫做Component，Component类定义有两种，见#3

#3   ---   两种定义Component的方法：1）在其他qml文件中定义(嵌入式)                       见：动态加载/1
				    2）在以自己名字定义的qml文件中定(单独文件式)         见：动态加载/2
				
#4   ---   两种使用Component的方法：1）直接使用文件名					 见：动态加载/2
				    2）使用Loader类					 见：动态加载/1，动态加载/3

=========================================================================================================================================================

#5   ---   在QT中，信号触发就是函数调用
	   有两种触发信号的方法：1）直接使用   id.func()  ,  即直接使用实例+信号函数的方式  （这里信号函数是使用signal关键字声明函数） ， 这种情况仅适合在同一个qml文件中。跨文件的id不共享
				 2）通过emit，如果一个qml文件或者c++文件中想使用另一个qml文件中通过signal定义的信号函数，则必须使用emit函数来触发，表示”此时此刻我要发信号了“，也就是会说
                                    ”此时此刻我要调用信号处理函数了“
	   
=========================================================================================================================================================

#6   ---   在c++和QT中，signal关键字修饰的信号，其实是一个对象，它有connect方法和disconnect方法。可以使用它连接到任意的方法(函数)上。

=========================================================================================================================================================

#7   ---   接#6，举个例子：
                
		Rectangle{
			id:relay
			
			signal messageReceived(string person,string notice);	//创建一个信号实例，叫messageReceived，此信号可携带的参数列表为 person 和 notice
			
			Component.onComplete:{
			    relay.messageReceived.connect(sendToPost);		//   为信号实例注册一个信号处理函数sendToPost
			    relay.messageReceived.connect(sendToTelegraph);	//再 为信号实例注册一个信号处理函数sendToTelegraph
			    relay.messageReceived.connect(sendToEmail);		//再 为信号实例注册第三个信号处理函数sendToEmail
				
			    relay.messageReceived("xxx","yyy")			//触发信号，可以理解为为信号实例messageReceived”“”“调用构造函数”“”“
			}
			
			function sendToPost(person,notice){
					func(person,notice);			//处理传进来的参数person和notice
			}
			function sendToTelegraph(xxx,yyy){
					func(xxx,yyy);				//处理传进来的参数xxx和yyy，这里具体参数叫什么名字不重要，只要知道对应于信号的两个参数就行了
			}
			function sendToEmail(person,notice){
					func(person,notice);
			}
		}

=========================================================================================================================================================

#8   ---  onXxxxed:{
	    ...
	  }
          上述形式声明信号处理函数，其实对应了三条语句：1） signal xxxxed();
							2） function func(){
								...
							    }   
							3） xxxxed.connect(func);

		ps:因为信号的本质是函数，所以可以有函数调用的嵌套，即触发信号后，在信号处理函数中再触发信号。（恩，这是理所应当的，如果不能嵌套调用就太2了）

=========================================================================================================================================================

#9   ---  信号的定义、使用、挂载本文件的处理函数、挂载其他文件的处理函数、在任何地方对某个信号实例增加信号处理函数  
			
				见：信号与槽/1

 
















