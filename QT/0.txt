#1   ---   c++和QML结合使用：
		1）思路：a.把c++类注册到QML中，成为一个QML类，再通过QML来创建和使用
			 b.把c++类实例化一个实例，然后把这个实例传给QML，QML直接使用对这个实例操作
		    小结：不论如何，都是把c++代码做成封装，给QML调用，这个和QML语言的实现思路是一致的，都是通过c++写底层，然后中间封装一层，再提供QML接口，
                          起始也就“相当于自己扩展开发QML语言了”

		2）准备：a.在c++类必须继承Qobject类
			 b.在c++类的开头必须使用Q_OBJECT宏

=========================================================================================================================================================

#2   ---   手段：1）通过信号和槽  互相关联
			 QML中有信号和槽，c++中也有信号和槽。而且QML和c++的信号和槽是互通的，那么就可以用这个机制来做关联。
			 在QML中注册信号和槽，来对应c++中的槽和信号。
				QML	 c++
				信号-----槽
				槽-------信号

		 2）通过Q_INVOKABLE宏  使用c++类方法
			凡是被此宏修饰的public成员方法都可以在QML中使用，使用方法就是  类名.方法

		 3）通过Q_ENUMS宏  使用c++类的枚举成员变量
			凡是被此宏处理过的枚举类型，都可以在QML中使用，方法为  类名.枚举的值  (这里不是 类名.枚举类型名.枚举的值)(那如果修饰了多个枚举类型怎么办？)

		 4）

=========================================================================================================================================================

如果想要模块化编程，那么就要单独定义一些模块，在QT里，这些可被其他qml引用的模块就叫做Component，Component类定义有两种，见#3

#3   ---   两种定义Component的方法：1）在其他qml文件中定义(嵌入式)                       见：动态加载/1
				    2）在以自己名字定义的qml文件中定(单独文件式)         见：动态加载/2
				
#4   ---   两种使用Component的方法：1）直接使用文件名					 见：动态加载/2
				    2）使用Loader类					 见：动态加载/1，动态加载/3






7.2.2
