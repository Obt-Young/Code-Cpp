模板函数有一定的局限性，比如入参的类型和函数流程中能接受的类型不匹配,此时会在编译的时候报错，可以理解为，模板函数在编译时会被翻译成
相应的特定函数实现，那么函数实现本身有问题，自然是会报错的。比如：

template <typename T>
void func(T a,T b)
{
	a=b;
}
如果a是结构体，b是数组的话，就会出现数组赋值给结构体的错误。
	注：这里说到，a是结构体，b是数组，这样传入模板函数是可以编译通过的。但是！！！如果a是int，b是float，那么编译无法通过，因为模板中
		要求a和b的类型一致，而int和float明显无法满足模板的要求


如果有：
template <typename T>
void func(T a,T b)
{
	a=b;
}
那么，如下函数是可以匹配上的：
int a=1;b=2;
int &c=a;
int &d=b;
func(c,d);
也就是说，c++把&看成是一种类型，即(int &) = T,但是，很可能作用和功能会受到限制，比如1.cpp的swap功能就失效了。
同理(int *)=T，但是函数功能也可能不定，而且指针操作还可能导致非法内存访问
