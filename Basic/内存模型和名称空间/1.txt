#1  -  编写代码文件时的拆分思路：
.h文件中包含属性域和方法声明，.c文件中包含方法的实现。这样在使用此文件提供的方法的时候，只要包含.h头文件即可。这也是一种“面向对象”的设计思路。
包含头文件意味着在预编译的时候声明了属性域，并且声明了方法，那么在链接的时候就不存在找不到符号表的问题，但是这里需要避免重复include，方法就是
???.c
#include xxx.h

xxx.h
#ifndef _XXX_H
#define _XXX_H
...
...
...
...
#endif

不要在头文件中声明变量，头文件中仅用来定义变量类型就好，千万不要出现某个实实在在的变量，比如可以定义结构体，定义枚举类型，定义联合体，但是
不要在其中声明某个结构体实例。因为会导致变量重复定义的情况出现。

头文件中一般包含如下内容：函数声明，使用#define和const定义的常量，结构体声明，类声明，模板声明，内联函数
总之一句话，不要在头文件中出现任何格式的“实例”，头文件只做声明用。
PS：由于const的特殊链接性质，可以在头文件中定义(具体是什么样的性质？)


#2  -  编译的兼容性
C++标准允许每个编译器设计人员自定义名称符号表(symbol table)中条目的格式，因此由不同编译器对相同源文件实施编译的最终结果可能是不一样的，因为
符号表的格式不通，比如func函数，在通用编译器输出的符号表中是func，而在yk自定义的编译器输出的符号表中是func_yk，这样在链接时就会出现互相找不到
的问题，虽然他们代表的代码逻辑都是一样的。
因此，尽量整个工程编译；如果无法整个工程编译，那么就用objdump命令逐条核实二进制文件的符号表；亦或者，确认各个二进制文件的编译器使用的是同一个。


#3  -  编译器会提供栈容编译选项

#4  -  c++提供了作用域解析运算符 ::  ,  如果有全局变量a和局部变量a，那么在函数栈中使用 ::a来使用a的全局变量版本

#5  -  程序越能避免对数据进行不必要的访问，就越能保证数据的完整性，因此尽量把变量的作用域收缩到适合其使用的范围。

#6  -  1.c和2.c中如果都有int a这个全局变量，那么单独编译OK，链接时候无法通过；不指定为static的全局变量的链接性默认为外部链接。两个int a，如果一个
       是static的，则没问题，可编译也可链接，static为内部链接属性。

#7  -  volatile关键字:告诉编译器“虽然程序没有修改某个变量，但是这个变量也可能会改变，因此在编译时不要做优化”，比如某个指向硬件缓冲区的指针，缓冲区
       里的内容由硬件驱动来改变，因此随时都可能改变而且应用软件也不知道，这种情况下，程序就应该按部就班的执行，而不是让编译器自作主张地优化语句。

#8  -  mutable int a;    mutable一般用在const结构体和类中，用来特别标注，虽然当前结构体/类是const的，是不可更改的，但是其中用mutable声明的成员是特例，
       可以修改！！！

#9  -  语言的链接性(符号表的翻译和查找规则) : 链接程序要求每个函数的函数名都是独一无二的(这是编译器要求的)，在C语言中，不存在函数的多态，因此事OK的；
       在c++中，存在函数的多态，这就会存在冲突，因此c++编译器会为相同的函数名打上不同的标签。
       综上，c编译器和c++编译器在编译时的处理时不一样的，那么既有c又有c++的程序，在定义函数的时候，就需要指明当前函数该如何处理，默认情况下，编译器
       会根据文件后缀是.c还是.cpp来自动处理，但是如果想在.cpp文件中引用c函数，那么就需要使用extern "C" void func(void)来申明，同理在.c文件中，需要用
       extern "C++" void func(void)来声明c++库/源文件中的函数。

#10 -  new的奇葩用法：
          已知两个全局数组变量char buff1[50];
                              char buff2[100];

          char * p1 = new (buff1) int[20];     //从buff1中拿出来int[20]需要的空间给他，p1指向这段空间的起始

---------------------------------------------------------------------------------------------------------------------------------------------------

名称空间
       
#1  -  名称空间的使用通过 ::运算符，但总是使用这个运算符，就会增加写代码的工作量，因此using就出现了
       using std::cout;   //使用std名称空间的cout
       cout << endl;      
       
       using namespace std;   //编译时，使用std名称空间中的所有符号
       cout << endl;

       注：名称空间和变量具有相同的作用范围机制，比如：
           {
		using namespace std;
	   }
		cout << endl;	//这里就不行，因为std的作用域仅在限于括号内

#2  -  一般来说，使用“using声明”比“using编译”更安全，因为控制范围的粒度更小

#3  -  名称空间的创建存在嵌套性：
	namespce a{
		namespace b{
			int c;
		}
	}
	引用c的方法:      a::b::c
	
#4  -  可以给名称空间建别名，比如   namespace AB = a::b
       此时在访问c，就可以  AB::c
		（这里的a和b都是名称空间，b在a内，属于嵌套结构：namespace a{
								     int xxx;
								        namespace b{
									   int c;
									}
								     int yyy;
								}
		  为了使用方便，就把using namespace a:b:ccc  ,  简化成 using namespace AB:c

		 ）

#5  -  名称空间的定义:namespace{ }
       名称空间的使用:using namespace xxx;	     //using编译
       名称空间的使用:using namespace xxx:func;      //using声明
		
#6  -  既然有名称空间做约束，那么1.cpp和2.cpp中都有void func(int,int)时，链接时是否能通过呢?(在文件中对func做namespace约束)

#7  -  名称空间存在的意义：如果有lib1和lib2，且这两个lib里面都有方法get，在c里面，如果同时链接这两个库，就会导致符号表冲突，链接失败，解决办法只有重命名get的名字，
       比如lib1_get,lib2_get。这就比较麻烦。在C++里面，可以通过为两个lib设置名称空间来解决，比如lib1设置名称空间lib1，lib2设置lib2，这样就不需要重新编译库文件，只要
       在使用的时候如下:lib1:get  /  lib2:get

#8  -  名称空间的使用作用域机制和变量作用域机制一样

#9  -  名称空间的声明不能再代码块中，和结构体一样

#10 -  名称空间可以嵌套，和结构体一样

#11 -  可以把名称空间当做符号表，那么在使用的时候就需要提前,如果名称空间定义在.h文件中，那么需要include这个头文件(类比结构体)

#12 -  using声明：   using yk::get;
			get("xxx");	
			...
			get("yyy");
	using声明的潜台词：后面只要使用get，那么就是yk名称空间下的那个get(作用域和变量一致)

       using编译指令：    using namespace yk;
	using编译指令


#13 -  冒号的用法：
		双冒号：
		1）类成员函数定义时，这种情况好辨别，是双冒号 :: ，然后是在函数外部顶头写
		2）使用名称空间，namespace::instance，这种情况与1）的区别在于，instance后面不跟大括号来表示函数定义
		3）对成员的引用，比如 有people类，zhangsan实例，showname方法，那么就可以 zhangsan::showname(), 这个是等价于zhangsan.showname()的，这一点需要注意，这个设计简直就是“傻逼”，
		   完全和2）没法分辨，简直脑残。
		单冒号：
		1）继承
		2）














