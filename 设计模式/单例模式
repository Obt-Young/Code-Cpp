单例模式的描述：
使用一个“静态成员函数”代替“构造函数”来获取一个类实例，并把实例赋值给一个“静态成员变量”类指针，后面所有试图获取类实例的动作都
将获得那个静态的类指针，因为静态成员变量是类共享的，所以实现了单例。

单例模式的要点：
1）构造函数必须private，防止直接实例化
2）必须有一个静态成员函数来代替原有构造函数的功能
3）必须有一个全局静态类之后怎，用来存放单例的实例地址


--------------------------------------------案例--------------------------------------------

alarmhandler.h

class AlarmHandler{

public:
        static AlarmHandler* createAlarmHandler();              //静态成员函数，用来创建单例

private:
        AlarmHandler::AlarmHandler();                           //private的构造函数，这样createAlarmHandler就是类
                                                                //的唯一入口了，那么在入口做一个NULL检查就实现了单例

}




alarmhandler.cpp

static AlarmHandler * myAlarmHandler = NULL;                    //静态成员变量，用来存放单例指针

AlarmHandler *AlarmHandler::createAlarmHandler()
{
        if(myAlarmHandler == NULL)
        {
                myAlarmHandler = new AlarmHandler();
        }
        return myAlarmHandler;
}

AlarmHandler::AlarmHandler()
{
}

--------------------------------------------案例----------------------------------------------

小结：静态成员函数比实例先被创建，其他的成员函数和变量在类未创建时，“都是不存在的”（还没有被分配到堆里面），但是构造函数
        是可以调用的，因为构造函数本身是一个分配内存的函数，是特别的。因此单例模式的中心思想就是 “使用静态成员函数这个
        独立于实例的东西，来调用能够分配内存的 ‘构造函数’”

        但是，单例的使用，必须要求以后使用都不在使用“构造函数”来创建实例，转而使用指定的静态成员函数来创建，当然，也可以
        通过构造函数来创建实例，这样就拜托了单例模式，也是去了设计模式的意义。
        （PS：单例模式其实要求构造函数是private，这样外界是没法使用构造函数的）

        总的来说，单例模式 是一种 巧计， 巧妙利用static成员变量被所有实例共享这一特点，同时把构造函数设计成private，让
        外界不可调用，这样静态成员函数就成了这个类的唯一入口，那么我在入口的地方在做一次筛选，判断如果当前已经有实例，就
        不再调用构造函数，这样就实现了到哪里模式
